import heapq
class Graph:
    def __init__(self,vertices):
        self.V=vertices
        self.adj_list={i:[] for i in range(vertices)}
    def add_edge(self,u,v,w):
        self.adj_list[u].append((v,w))
        self.adj_list[v].append((u,w))
    def prim_mst(self):
        visited=[False]*self.V
        min_heap=[(0,0,-1)]
        mst=[]

        while min_heap:
            weight,u,parent=heapq.heappop(min_heap)
            if visited[u]:
                continue
            visited[u]=True

            if parent!=-1:
                mst.append((parent,u,weight))

            for v,w in self.adj_list[u]:
                if not visited[v]:
                    heapq.heappush(min_heap, (w,v,u))

        print("Minimum Spanning Tree:")
        for u, v, w in mst:
            print(f"{u} -- {v} == {w}")

g=Graph(5)
g.add_edge(0, 1, 10)
g.add_edge(0, 2, 20)
g.add_edge(1, 2, 5)
g.add_edge(1, 3, 15)
g.add_edge(2, 3, 30)
g.add_edge(3, 4, 10)
g.add_edge(2, 4, 25)

g.prim_mst() 
